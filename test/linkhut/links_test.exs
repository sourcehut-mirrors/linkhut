defmodule Linkhut.LinksTest do
  use Linkhut.DataCase

  import Linkhut.Factory

  alias Linkhut.Links
  alias Linkhut.Links.Link
  alias Linkhut.AccountsFixtures

  describe "create_link/2" do
    setup do
      user = AccountsFixtures.user_fixture()

      valid_attrs = %{
        url: "https://example.com/test",
        title: "Test Title",
        notes: "Some **markdown** content.",
        tags: ["elixir", "test"],
        is_private: true,
        is_unread: false
      }

      %{user: user, valid_attrs: valid_attrs}
    end

    test "successfully creates a link", %{user: user, valid_attrs: attrs} do
      assert {:ok, %Link{} = link} = Links.create_link(user, attrs)
      assert link.url == "https://example.com/test"
      assert link.title == "Test Title"
      assert link.notes == "Some **markdown** content."
    end

    test "requires url", %{user: user, valid_attrs: attrs} do
      required = [:url]

      for field <- required do
        invalid_attrs = Map.delete(attrs, field)
        {:error, changeset} = Links.create_link(user, invalid_attrs)
        refute changeset.valid?
        assert Access.get(errors_on(changeset), field) != []
      end
    end

    test "url must be valid with scheme and host", %{user: user} do
      for {invalid_url, error_msg} <- [
            {"example.com", "is missing a scheme"},
            {"https:", "is missing a host"},
            {"", "can't be blank"}
          ] do
        {:error, changeset} =
          Links.create_link(user, %{
            url: invalid_url,
            title: "Test",
            is_private: true
          })

        refute changeset.valid?
        assert %{url: [error]} = errors_on(changeset)
        assert error == error_msg
      end
    end

    test "notes generate notes_html", %{user: user, valid_attrs: attrs} do
      {:ok, link} = Links.create_link(user, attrs)

      assert link.notes_html =~ "<p>\nSome <strong>markdown</strong> content.</p>\n"
    end

    test "title is autogenerated from URL if not provided", %{user: user, valid_attrs: attrs} do
      for {html, idx} <-
            Enum.with_index([
              "<html><head><title>Fetched Title</title></head></html>",
              "<html><head><title>Not this title</title><meta property=\"og:title\" content=\"Fetched Title\" /></head></html>",
              "<html><body><h1>Fetched Title</h1><h1>Not the fetched title</h1></body></html>"
            ]) do
        Req.Test.stub(Linkhut.Links.Link, fn conn ->
          Req.Test.html(conn, html)
        end)

        attrs = Map.drop(attrs, [:title])
        attrs = Map.put(attrs, :url, "http://example.com/#{idx}")

        {:ok, link} = Links.create_link(user, attrs)
        assert link.url == "http://example.com/#{idx}"
        assert link.title == "Fetched Title"
      end
    end

    test "title fallback to path or host on failed fetch", %{user: user, valid_attrs: attrs} do
      for {url, title} <- [
            {"https://example.com/foo/bar.pdf", "bar.pdf"},
            {"https://example.com", "example.com"},
            {"https://foo.example.com", "foo.example.com"},
            {"http://localhost:8080", "localhost"},
            {"http://127.0.0.1:8080", "127.0.0.1"},
            {"http://10.0.0.1", "10.0.0.1"},
            {"http://192.168.0.1/", "192.168.0.1"},
            {"http://172.31.0.1/foo/", "foo"},
            {"http://[fc00::1]", "fc00::1"},
            {"http://[::1]:8080", "::1"}
          ] do
        Req.Test.stub(Linkhut.Links.Link, fn conn ->
          Req.Test.transport_error(conn, :closed)
        end)

        attrs = Map.drop(attrs, [:title])
        attrs = Map.put(attrs, :url, url)

        {:ok, link} = Links.create_link(user, attrs)
        assert link.title == title
      end
    end

    test "title is fallback to path or host on failed fetch", %{user: user, valid_attrs: attrs} do
      Req.Test.stub(Linkhut.Links.Link, fn conn ->
        Req.Test.transport_error(conn, :timeout)
      end)

      attrs = Map.drop(attrs, [:title])
      attrs = Map.put(attrs, :url, "https://example.com/foo/bar")

      {:ok, link} = Links.create_link(user, attrs)
      assert link.title == "bar"
    end

    test "deduplicates tags case-insensitively and preserves 'unread'", %{
      user: user,
      valid_attrs: attrs
    } do
      tags = ["Elixir", "elixir", "unread"]
      {:ok, link} = Links.create_link(user, Map.put(attrs, :tags, tags))
      assert link.tags == ["Elixir", "unread"]
    end

    test "adds 'unread' tag if is_unread is true", %{user: user, valid_attrs: attrs} do
      attrs = Map.put(attrs, :is_unread, true)
      {:ok, link} = Links.create_link(user, attrs)
      assert "unread" in link.tags
    end

    test "enforces max length on title and notes", %{user: user, valid_attrs: attrs} do
      {:error, changeset} =
        Links.create_link(user, %{
          attrs
          | title: String.duplicate("a", 300),
            notes: String.duplicate("b", 2000)
        })

      refute changeset.valid?
      assert "should be at most 255 character(s)" in errors_on(changeset).title
      assert "should be at most 1024 character(s)" in errors_on(changeset).notes
    end
  end

  describe "update_link/2" do
    setup context do
      user = AccountsFixtures.user_fixture()

      valid_attrs =
        %{
          url: "https://example.com/test",
          title: "Test Title",
          notes: "Some **markdown** content.",
          tags: ["elixir", "test"],
          is_private: true,
          is_unread: false
        }
        |> Map.merge(Map.get(context, :extra_attrs, %{}))

      {:ok, link} = Links.create_link(user, valid_attrs)

      %{user: user, link: link, valid_attrs: valid_attrs}
    end

    @tag extra_attrs: %{tags: ["unread"]}
    test "removes 'unread' tag if is_unread is false", %{link: link, valid_attrs: attrs} do
      attrs = Map.put(attrs, :is_unread, false)
      {:ok, link} = Links.update_link(link, attrs)
      refute "unread" in link.tags
      refute link.is_unread
    end

    test "is_unread is set if tags include 'unread'", %{link: link, valid_attrs: attrs} do
      attrs = Map.put(attrs, :tags, ["elixir", "unread"])
      {:ok, link} = Links.update_link(link, attrs)
      assert link.is_unread
    end
  end

  describe "link queries" do
    setup do
      user = AccountsFixtures.user_fixture()

      {:ok, link1} =
        Links.create_link(user, %{
          url: "https://example.com/1",
          title: "Example 1",
          tags: ["test"],
          is_private: false,
          is_unread: false
        })

      :timer.sleep(1000)

      {:ok, link2} =
        Links.create_link(user, %{
          url: "https://example.com/2",
          title: "Example 2",
          tags: ["test"],
          is_private: true,
          is_unread: false
        })

      :timer.sleep(1000)

      {:ok, link3} =
        Links.create_link(user, %{
          url: "https://example.com/3",
          title: "Example 3",
          tags: ["test"],
          is_private: false,
          is_unread: true
        })

      assert %{failure: 0} = Oban.drain_queue(queue: :default)

      %{user: user, links: [link1, link2, link3]}
    end

    test "get/2 returns link by URL and user_id", %{user: user} do
      assert %Link{} = link = Links.get("https://example.com/1", user.id)
      assert link.title == "Example 1"
    end

    test "get!/2 returns link or raises error", %{user: user} do
      assert %Link{} = Links.get!("https://example.com/1", user.id)

      assert_raise Ecto.NoResultsError, fn ->
        Links.get!("nonexistent", user.id)
      end
    end

    test "all/1 with user returns all user links", %{user: user} do
      links = Links.all(user)
      assert length(links) == 3
    end

    test "all/1 with visibility filter returns appropriate links", %{user: user} do
      public_links = Links.all(visible_as: :public)
      assert length(public_links) == 1

      user_visible_links = Links.all(visible_as: user.id)
      assert length(user_visible_links) == 3
    end

    test "unread_count/1 returns count of unread links", %{user: user} do
      assert Links.unread_count(user.id) == 1
    end

    test "most_recent/1 returns most recently modified link", %{user: user} do
      recent = Links.most_recent(user)
      assert recent.url == "https://example.com/3"
    end
  end

  describe "filtering and ordering" do
    setup do
      user = AccountsFixtures.user_fixture()

      {:ok, _} =
        Links.create_link(user, %{
          url: "https://example.com/1",
          title: "Example 1",
          tags: ["elixir"],
          inserted_at: DateTime.add(DateTime.utc_now(), -2, :day)
        })

      {:ok, _} =
        Links.create_link(user, %{
          url: "https://example.com/2",
          title: "Example 2",
          tags: ["elixir", "phoenix"]
        })

      %{user: user}
    end

    test "all/1 with tag filter returns matching links", %{user: user} do
      phoenix_links = Links.all(user, tags: ["phoenix"])
      assert length(phoenix_links) == 1

      elixir_links = Links.all(user, tags: ["elixir"])
      assert length(elixir_links) == 2
    end

    test "all/1 with date range filter returns matching links", %{user: user} do
      from = DateTime.add(DateTime.utc_now(), -1, :day)
      links = Links.all(user, from: from)
      assert length(links) == 1
    end

    test "all/1 with search query returns matching links", %{user: user} do
      links = Links.all(user, query: "Example 1")
      assert length(links) == 1
      assert hd(links).title == "Example 1"
    end
  end

  describe "recent/2 with account age filter" do
    setup do
      # Create users with different account ages
      # 60 days old (should be included)
      old_user = AccountsFixtures.user_fixture()
      AccountsFixtures.override_user_inserted_at(old_user.id, 60)
      # Exactly 30 days old (should be included)
      boundary_user = AccountsFixtures.user_fixture()
      AccountsFixtures.override_user_inserted_at(boundary_user.id, 30)
      # 10 days old (should be excluded)
      new_user = AccountsFixtures.user_fixture()
      AccountsFixtures.override_user_inserted_at(new_user.id, 10)

      # Create recent links for each user
      {:ok, old_user_link} =
        Links.create_link(old_user, %{
          url: "https://example.com/old",
          title: "Old User Link",
          tags: ["test"]
        })

      {:ok, boundary_user_link} =
        Links.create_link(boundary_user, %{
          url: "https://example.com/boundary",
          title: "Boundary User Link",
          tags: ["test"]
        })

      {:ok, new_user_link} =
        Links.create_link(new_user, %{
          url: "https://example.com/new",
          title: "New User Link",
          tags: ["test"]
        })

      assert %{failure: 0} = Oban.drain_queue(queue: :default)

      %{
        old_user_link: old_user_link,
        boundary_user_link: boundary_user_link,
        new_user_link: new_user_link
      }
    end

    test "excludes links from users created within 30 days", %{
      old_user_link: old,
      boundary_user_link: boundary,
      new_user_link: new
    } do
      recent_links = Links.recent([]) |> Linkhut.Repo.all()

      # Should only include links from users 30+ days old
      link_urls = Enum.map(recent_links, & &1.url)

      assert old.url in link_urls
      assert boundary.url in link_urls
      refute new.url in link_urls
    end
  end

  describe "delete_link/1" do
    setup do
      user = AccountsFixtures.user_fixture()

      {:ok, link} =
        Links.create_link(user, %{
          url: "https://example.com/delete-test",
          title: "Delete Test",
          tags: ["test"],
          is_private: true
        })

      %{user: user, link: link}
    end

    test "marks snapshots as pending_deletion and enqueues cleanup job", %{link: link} do
      snapshot = insert(:snapshot, link_id: link.id, state: :complete)

      assert {:ok, _} = Links.delete_link(link)

      updated = Repo.get(Linkhut.Archiving.Snapshot, snapshot.id)
      assert updated.state == :pending_deletion
      assert updated.link_id == nil

      assert_enqueued(worker: Linkhut.Archiving.Workers.StorageCleaner)
    end

    test "succeeds when link has no snapshots", %{link: link} do
      assert {:ok, _} = Links.delete_link(link)
    end
  end

  describe "has_archive?" do
    setup do
      user = AccountsFixtures.user_fixture()

      {:ok, link} =
        Links.create_link(user, %{
          url: "https://example.com/snapshot-test",
          title: "Snapshot Test",
          tags: ["test"],
          is_private: false
        })

      assert %{failure: 0} = Oban.drain_queue(queue: :default)

      %{user: user, link: link}
    end

    defp fetch_link_with_archive(link, opts \\ []) do
      opts
      |> Links.links()
      |> where(url: ^link.url)
      |> Repo.one!()
    end

    test "returns true when link has a processing archive with no snapshots", %{
      user: user,
      link: link
    } do
      insert(:archive,
        link_id: link.id,
        user_id: user.id,
        url: link.url,
        state: :processing
      )

      result = fetch_link_with_archive(link, current_user_id: user.id)
      assert result.has_archive? == true
    end

    test "returns true when link has a failed archive", %{user: user, link: link} do
      insert(:archive,
        link_id: link.id,
        user_id: user.id,
        url: link.url,
        state: :failed,
        error: "HEAD preflight failed"
      )

      result = fetch_link_with_archive(link, current_user_id: user.id)
      assert result.has_archive? == true
    end

    test "returns false when link has only pending_deletion archives", %{user: user, link: link} do
      insert(:archive,
        link_id: link.id,
        user_id: user.id,
        url: link.url,
        state: :pending_deletion
      )

      result = fetch_link_with_archive(link, current_user_id: user.id)
      assert result.has_archive? == false
    end

    test "returns false when link has no archives", %{user: user, link: link} do
      result = fetch_link_with_archive(link, current_user_id: user.id)
      assert result.has_archive? == false
    end

    test "returns false for another user's link", %{link: link} do
      other_user = AccountsFixtures.user_fixture()

      insert(:archive,
        link_id: link.id,
        user_id: link.user_id,
        url: link.url,
        state: :processing
      )

      result = fetch_link_with_archive(link, current_user_id: other_user.id)
      assert result.has_archive? == false
    end

    test "returns false when no current_user_id is provided", %{link: link} do
      insert(:archive,
        link_id: link.id,
        user_id: link.user_id,
        url: link.url,
        state: :processing
      )

      result = fetch_link_with_archive(link)
      assert result.has_archive? == false
    end

    test "populates has_archive? per-link independently", %{user: user, link: link} do
      {:ok, other_link} =
        Links.create_link(user, %{
          url: "https://example.com/other",
          title: "Other",
          tags: ["test"]
        })

      assert %{failure: 0} = Oban.drain_queue(queue: :default)

      insert(:archive,
        link_id: link.id,
        user_id: user.id,
        url: link.url,
        state: :processing
      )

      results =
        Links.links(current_user_id: user.id)
        |> where([l], l.url in ^[link.url, other_link.url])
        |> Repo.all()
        |> Map.new(&{&1.url, &1.has_archive?})

      assert results[link.url] == true
      assert results[other_link.url] == false
    end
  end
end
